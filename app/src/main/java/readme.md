Здесь описываем что зачем и почему
Нам нужно несколько таблиц куда юзер будет запишивать список покупок
lesson 2-3 создаем таблицы БД
Вторая таблица для самих продуктов
Entity это модель БД
С помощью либы Room мы создаем аннотацию и таблицы нашей БД
entities хранит все модели наших таблиц
В моелях создаем dataClasses
@Entity(tableName = "shopping_list_names") Это таблица и модель только для записи Имен списков, например на рыбалку, новый год и т.д.
@ это аннотация для Room Lib
@Serializable это передача класса в другие классы, мы можем передавать из активити в активити весь класс, а не отдельные переменные
@Entity(tableName = "shop_list_item") Это таблица и модель для элемента закупки(картошка, моркошка или крючки, леска, грузила)
У данной таблице тоже должен быть id чтобы обратиться к этому списку у поменять что-то у элемента
@Entity(tableName = "note_list")
Это таблица для хранения записей
@Entity(tableName = "library")
Это таблица для описания элементов списка (яблоко, и т.д.) мы ее будем наполнять
В БД мы через ROOM будем пилить эти Таблички
lesson 4
class MainDataBase это главный класс или наша БД, наследуем от билблиотеки ROOM и получаем БД
указываем companion object тогда мы можем обращаться к БД через точку например MainDataBase.функция
и наш класс должен быть abstract
@Volatile дает доступность к БД всех потоков
private var INSTANCE:MainDataBase? = null это экземпляр нашего класса, благодаря Volatile мы имеем достпу к INSTANCE
return INSTANCE ?: synchronized(this)  здесь мы возвращаем нашу БД оператор ?: если слева есть экземпляр нашей БД то вернем т.к. у нас будет уже БД, если нет то через synchronized
он читает поток если уже используется то не может запустить создание БД, а если поток свободен
через Room.databaseBuilder создаем БД именно текущего экземпляра this, он читает поток если уже используется то не может запустить создание БД
Указываем контекст, укажем AppContext чтобы всего активи взять и обращаться отовсюду к БД
Здесь указываем Базу и какие у нее есть таблицы, и так же версию
@Database(entities = [LibraryItem::class, NoteItem::class, ShoppingListItem::class, ShoppingListNames::class], version = 1)
class MainApp : Application() Создаем класс МайнАпп и в данном главном активити мы инициализируем нашу БД с доступом из всех активити
val database by lazy {
MainDataBase.getDataBase(this)
Делаем ленивую инициализацию БД, т.е. когда есть обращение и если у нас БД не существует, создает. А если есть БД то by lazy не будет работать.
НО правильно ли так делать, мы можем объявить БД в во ViewModel
lesson 5
@Dao
class Dao или Дата Акцесс Объект. Класс DAO нужен чтобы обращаться с БД, записывать или считывать инфу
